---
title: "Meta analysis - Single Network Anaylsis"
output: 
  github_document:
    html_preview: false
date: "2024-03-01"
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(echo= TRUE, warning = FALSE, message = FALSE, fig.path="../../../outputs/single-network-analysis/Individual/plots/Family/") 
```

```{r library-instalation}
myPaths <- .libPaths()
myPaths <- c(myPaths, "~/MetaIBS/MetaIBS-library")
myPaths <- c(myPaths[3], myPaths[1], myPaths[2])
.libPaths(myPaths)  # add new path
```

***********
# 1. IMPORT
***********

## 1.1. Libraries

```{r library-import}
library(phyloseq) # Handling and analysis of high-throughput microbiome census data.
library(tidyverse)
library(ggplot2)
library(SpiecEasi)
library(igraph)
library(VennDiagram)
library(NetCoMi)
```

```{r path-directories, echo=FALSE}
# ROOT DIRECTORY (to modify on your computer)
path.root <- "~/MetaIBS"
path.datasets    <- file.path(path.root, "data/Individual/phyloseq_without_tree")
path.phylobj    <- file.path(path.root, "data/Agglomeration/Individual")
path.outputs <- file.path(path.root, "outputs/single-network-analysis/Individual")
path.assoc_mat <- file.path(path.outputs , "association_matrices")
path.properties <- file.path(path.outputs , "network_properties")
path.plots <- file.path(path.outputs , "plots")

source("~/MetaIBS/scripts/functions.R")
datasets        <- list.files(path.datasets, pattern=".rds")
datasets_names  <- sub(".*_(.*)\\..*", "\\1", datasets)
agg_level <- "Family"
```

**************
# 2. FUNCTIONS
**************

```{r function, eval=TRUE}
# Function to load matrices and filter NULL entries
load_matrices <- function(datasets_names, path.assoc_mat, agg_level, object_index) {
  matrices <- lapply(datasets_names, function(x) {
    tryCatch({
      load(file = file.path(path.assoc_mat, agg_level, paste0("AssocMat_", x, ".RData")))
      objects <- ls()  # Get loaded objects
      return(get(objects[object_index]))  # Return the specified object
    }, error = function(e) {
      message(paste("Skipping file:", x, "due to error:", e$message))
      return(NULL)
    })
  })
  Filter(Negate(is.null), matrices)  # Remove NULL entries
}

# Function to plot meta-analysis
plot_meta_analysis <- function(meta, layout = NULL, title = "Meta-Analysis", repulsion = 0.5) {
  props_asso_meta <- network_construct(meta, thresh = 0.1)
  plot(props_asso_meta,
       layout = layout,
       repulsion = repulsion,
       sameLayout = TRUE,
       nodeColor = "cluster",
       labelScale = FALSE,
       rmSingles = TRUE,
       nodeSize = "eigenvector",
       cexNodes = 0.58,
       cexLabels = 0.7,
       cexHubLabels = 1,
       title1 = title,
       showTitle = TRUE,
       cexTitle = 2,
       hubBorderCol = "gray40")
}

# Function to process individual plots
plot_individual_networks <- function(matrices, meta, layout, datasets_names) {
  for (i in seq_along(matrices)) {
    sub_adj <- matrices[[i]]
    
    # Skip if no connected nodes
    if (sum(sub_adj)== 0) {
      message(paste0("Skipping network ", datasets_names[i], " due to no connected nodes."))
      next
    }
    
    common_rows <- intersect(rownames(meta), rownames(sub_adj))
    common_cols <- intersect(colnames(meta), colnames(sub_adj))

    filtered_meta_adj <- meta
    filtered_meta_adj[,] <- 0
    
    filtered_meta_adj[common_rows, common_cols] <- meta[common_rows, common_cols] * (sub_adj[common_rows, common_cols] != 0)
    
    props_asso <- network_construct(filtered_meta_adj)
    plot(props_asso,
         layout = layout,
         nodeColor = "cluster",
         labelScale = FALSE,
         rmSingles = "none",#TRUE,
         nodeSize = "eigenvector",
         cexNodes = 0.58,
         cexLabels = 1.5,
         cexHubLabels = 1.7,
         title1 = paste0("Network Analysis ", str_to_title(datasets_names)),
         showTitle = TRUE,
         cexTitle = 2,
         hubBorderCol  = "gray40")
  }
}

# Function to process individual plots
plot_individual_network <- function(matrix, meta, layout,  datasets_names, method) {

  sub_adj <- matrix
    
    # Skip if no connected nodes
  if (sum(sub_adj)== 0) {
    message(paste0("Skipping network ", datasets_names[i], " due to no connected nodes."))
    next
  }
    
  common_rows <- intersect(rownames(meta), rownames(sub_adj))
  common_cols <- intersect(colnames(meta), colnames(sub_adj))

  filtered_meta_adj <- meta
  filtered_meta_adj[,] <- 0
    
  filtered_meta_adj[common_rows, common_cols] <- meta[common_rows, common_cols] * (sub_adj[common_rows, common_cols] != 0)
    
  props_asso <- network_construct(filtered_meta_adj)
  plot(props_asso,
         layout = layout,
         nodeColor = "cluster",
         labelScale = FALSE,
         rmSingles = "none",#TRUE,
         nodeSize = "eigenvector",
         cexNodes = 0.58,
         cexLabels = 0.7,
         cexHubLabels = 1,
         title1 = paste0("Network Analysis ",  str_to_title(datasets_names)," ",method),
         showTitle = TRUE,
         cexTitle = 1.5,
         hubBorderCol  = "gray40")
  
}
```

******************
# 3. META-ANALYSIS
******************

## Meta-Analysis Plot

```{r meta-analysis, out.width="33%", fig.show="hold", fig.align="default", echo=FALSE}

matrices.gl <- load_matrices(datasets_names, path.assoc_mat, agg_level, 1)
meta.gl <- meta_analysis(matrices.gl, "mean")
result.gl <- plot_meta_analysis(meta.gl, title = "Meta-Analysis GLasso", repulsion = 0.4900003)

matrices.mb <- load_matrices(datasets_names, path.assoc_mat, agg_level, 2)
meta.mb <- meta_analysis(matrices.mb, "mean")
result.mb <- plot_meta_analysis(meta.mb, title = "Meta-Analysis MB", repulsion = 0.500001)

matrices.slr <- load_matrices(datasets_names, path.assoc_mat, agg_level, 3)
meta.slr <- meta_analysis(matrices.slr, "mean")
result.slr <- plot_meta_analysis(meta.slr, title = "Meta-Analysis SLR", repulsion = 0.6012)

```


```{r single-network, out.width="33%", fig.show="hold", fig.align="default", echo=FALSE}
layout.gl <- result.gl$layout$layout1
layout.mb <- result.mb$layout$layout1
layout.slr <- result.slr$layout$layout1

for (i in seq(matrices.gl)){
  mat.gl <- matrices.gl[[i]]
  mat.mb <- matrices.mb[[i]]
  mat.slr <- matrices.slr[[i]]
  
  plot_individual_network(mat.gl, meta.gl, layout.gl, datasets_names[[i]], "GLasso")
  plot_individual_network(mat.mb, meta.mb, layout.mb, datasets_names[[i]], "MB")
  plot_individual_network(mat.slr, meta.slr, layout.slr, datasets_names[[i]], "SLR")
}
```
******************
# 2. META-ANALYSIS
******************

## GLasso

### Meta-Analysis Plot

```{r meta-analysis-glasso, fig.width=18, fig.height=15, echo=FALSE}
matrices.gl <- lapply(datasets_names, function(x) {
  load(file=file.path(path.assoc_mat, agg_level, paste0("AssocMat_",x,".RData")))
  objects <- ls()
  return(get(objects[1]))
  })

meta.gl <- meta_analysis(matrices.gl, "mean")
props_asso_meta.gl <- network_construct(meta.gl, thresh=0.1)
# 
# png(file.path(path.plots, agg_level, paste0("Meta-Analysis.png")),
#       width=1800, height=1400)
result <- plot(props_asso_meta.gl,
       repulsion = 0.4900003,
       nodeColor = "cluster",
       labelScale = FALSE,
       rmSingles = TRUE,
       nodeSize = "eigenvector",
       cexNodes = 0.58,
       cexLabels = 1.5,
       cexHubLabels = 1.7,
       title1 = "Meta-Analysis",
       showTitle = TRUE,
       cexTitle = 2,
       hubBorderCol  = "gray40")#,
    # doPlot = F)$layout$layout1


```

### Individual Plots

```{r single-network-glasso, fig.width=18, fig.height=16, echo=FALSE}
layout <- result$layout$layout1

for (i in seq_along(matrices.gl)) {

  # Create a copy of the meta matrix to modify
  filtered_meta_adj <- meta.gl
  
  sub_adj <- matrices.gl[[i]]
  
  # Find the common row and column names between meta_adj and sub_adj
  common_rows <- intersect(rownames(meta.gl), rownames(sub_adj))
  common_cols <- intersect(colnames(meta.gl), colnames(sub_adj))
  
  # Set all elements in the large matrix to 0 initially
  filtered_meta_adj[,] <- 0
  
  # Now only retain the edges in the large matrix that overlap with the small matrix
  filtered_meta_adj[common_rows, common_cols] <- meta.gl[common_rows, common_cols] * (sub_adj[common_rows, common_cols] != 0)
  
  props_asso.gl <- network_construct(filtered_meta_adj)
  plot(props_asso.gl,
       layout = layout,
           nodeColor = "cluster",
           labelScale = FALSE,
             rmSingles = "none",#TRUE,
             nodeSize = "eigenvector",
             cexNodes = 0.58,
             cexLabels = 1.5,
             cexHubLabels = 1.7,
             title1 = paste0("Network Analysis ", str_to_title(datasets_names[i])),
             showTitle = TRUE,
             cexTitle = 2,
             hubBorderCol  = "gray40")
}


```
### Global Properties

```{r global-prop-gl, echo=FALSE}

properties.gl <- lapply(datasets_names, function(x) {
  load(file=file.path(path.properties, agg_level, paste0("NetProp_",x,".RData")))
  objects <- ls()
  return(get(objects[1]))
  })

names(properties.gl) <- datasets_names

glob_probs.gl <- lapply(properties.gl, function(data) {
    #data <- readRDS(file)
    data <- data$glob_probs_lcc
    data <- data[seq(1, length(data), by=2)]
    data
  })

merged_df <- do.call(cbind, glob_probs.gl)
colnames(merged_df) <- names(glob_probs.gl)
merged_df %>%
  knitr::kable(format = "markdown") 

```

## MB

### Meta-Analysis Plot

```{r meta-analysis-mb, fig.width=18, fig.height=15, echo=FALSE}

#fig.width=18.75, fig.height=14.58
matrices.mb <- lapply(datasets_names, function(x) {
  load(file=file.path(path.assoc_mat, agg_level, paste0("AssocMat_",x,".RData")))
  objects <- ls()
  return(get(objects[2]))
  })

meta.mb <- meta_analysis(matrices.mb, "mean")
props_asso_meta.mb <- network_construct(meta.mb, thresh=0.1)
# 
# png(file.path(path.plots, agg_level, paste0("Meta-Analysis.png")),
#       width=1800, height=1400)

result.mb <- plot(props_asso_meta.mb,
     repulsion = 0.500001,
       #layout = layout,
       nodeColor = "cluster",
       labelScale = FALSE,
       rmSingles = TRUE,
       nodeSize = "eigenvector",
       cexNodes = 0.58,
       cexLabels = 1.5,
       cexHubLabels = 1.7,
       title1 = "Meta-Analysis",
       showTitle = TRUE,
       cexTitle = 2,
       hubBorderCol  = "gray40")

```
### Individual Plots

```{r single-network-mb, fig.width=18, fig.height=16, echo=FALSE}
layout.mb <- result.mb$layout$layout1

for (i in seq_along(matrices.mb)) {
  # Create a copy of the meta matrix to modify
  filtered_meta_adj <- meta.mb
  
  sub_adj <- matrices.mb[[i]]
  
  # Find the common row and column names between meta_adj and sub_adj
  common_rows <- intersect(rownames(meta.mb), rownames(sub_adj))
  common_cols <- intersect(colnames(meta.mb), colnames(sub_adj))
  
  # Set all elements in the large matrix to 0 initially
  filtered_meta_adj[,] <- 0
  
  # Now only retain the edges in the large matrix that overlap with the small matrix
  filtered_meta_adj[common_rows, common_cols] <- meta.mb[common_rows, common_cols] * (sub_adj[common_rows, common_cols] != 0)
  
  props_asso.mb <- network_construct(filtered_meta_adj)
  plot(props_asso.mb,
       layout = layout.mb,
       nodeColor = "cluster",
       labelScale = FALSE,
       rmSingles = "none",
       nodeSize = "eigenvector",
       cexNodes = 0.58,
       cexLabels = 1.5,
       cexHubLabels = 1.7,
       title1 = paste0("Network Analysis ", str_to_title(datasets_names[i])),
       showTitle = TRUE,
       cexTitle = 2,
       hubBorderCol  = "gray40")
}

```
### Global Properties

```{r global-prop-mb, echo=FALSE}

properties.mb <- lapply(datasets_names, function(x) {
  load(file=file.path(path.properties, agg_level, paste0("NetProp_",x,".RData")))
  objects <- ls()
  return(get(objects[2]))
  })

names(properties.mb) <- datasets_names

glob_probs.mb <- lapply(properties.mb, function(data) {
    data <- data$glob_probs_lcc
    data <- data[seq(1, length(data), by=2)]
    data
  })

merged_df <- do.call(cbind, glob_probs.mb)
colnames(merged_df) <- names(glob_probs.gl)
merged_df %>%
  knitr::kable(format = "markdown") 

```

## SLR

### Meta-Analysis Plot

```{r meta-analysis-slr, fig.width=18, fig.height=16, echo=FALSE}

#fig.width=18.75, fig.height=14.58
matrices.slr <- lapply(datasets_names, function(x) {
  load(file=file.path(path.assoc_mat, agg_level, paste0("AssocMat_",x,".RData")))
  objects <- ls()
  return(get(objects[3]))
  })

meta.slr <- meta_analysis(matrices.slr, "mean")
props_asso_meta.slr <- network_construct(meta.slr, thresh=0)
# 
# png(file.path(path.plots, agg_level, paste0("Meta-Analysis.png")),
#       width=1800, height=1400)

result.slr <- plot(props_asso_meta.slr,
     repulsion = 0.6012,
    #layout = layout,
       nodeColor = "cluster",
       labelScale = FALSE,
       rmSingles = TRUE,
       nodeSize = "eigenvector",
       cexNodes = 0.58,
       cexLabels = 1.5,
       cexHubLabels = 1.7,
       title1 = "Meta-Analysis",
       showTitle = TRUE,
       cexTitle = 2,
       hubBorderCol  = "gray40")

```
### Individual Plots

```{r single-network-slr, fig.width=18, fig.height=16, echo=FALSE}
layout.slr <- result.slr$layout$layout1

for (i in seq_along(matrices.slr)) {
  # Create a copy of the meta matrix to modify
  filtered_meta_adj <- meta.slr
  
  sub_adj <- matrices.slr[[i]]
  
  # Find the common row and column names between meta_adj and sub_adj
  common_rows <- intersect(rownames(meta.slr), rownames(sub_adj))
  common_cols <- intersect(colnames(meta.slr), colnames(sub_adj))
  
  # Set all elements in the large matrix to 0 initially
  filtered_meta_adj[,] <- 0
  
  # Now only retain the edges in the large matrix that overlap with the small matrix
  filtered_meta_adj[common_rows, common_cols] <- meta.slr[common_rows, common_cols] * (sub_adj[common_rows, common_cols] != 0)
  
  props_asso.slr <- network_construct(filtered_meta_adj)
  plot(props_asso.slr,
       layout = layout.slr,
       nodeColor = "cluster",
       labelScale = FALSE,
       rmSingles = "none",
       nodeSize = "eigenvector",
       cexNodes = 0.58,
       cexLabels = 1.5,
       cexHubLabels = 1.7,
       title1 = paste0("Network Analysis ", str_to_title(datasets_names[i])),
       showTitle = TRUE,
       cexTitle = 2,
       hubBorderCol  = "gray40")
}

```
### Global Properties

```{r global-prop-slr, echo=FALSE}

properties.slr <- lapply(datasets_names, function(x) {
  load(file=file.path(path.properties, agg_level, paste0("NetProp_",x,".RData")))
  objects <- ls()
  return(get(objects[3]))
  })

names(properties.slr) <- datasets_names

glob_probs.slr <- lapply(properties.slr, function(data) {
    data <- data$glob_probs_lcc
    data <- data[seq(1, length(data), by=2)]
    data
  })

merged_df <- do.call(cbind, glob_probs.slr)
colnames(merged_df) <- names(glob_probs.gl)
merged_df %>%
  knitr::kable(format = "markdown") 

```